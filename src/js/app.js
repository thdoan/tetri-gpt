/*!
 * TetriGPT
 * @file A TetrisÂ® game coded by ChatGPT.
 * @author ChatGPT (2022 Dec 15 version)
 * @link https://github.com/thdoan/tetri-gpt
 */

/* NOTE: The code below was generated by ChatGPT (12/15/2022 version), with a few modifications. */

/*
This code will create a canvas element and append it to the body of the page. It will then
initialize the game board and create a new falling piece. The player can move the piece left and
right using the left and right arrow keys, rotate the piece using the up arrow key, and drop the
piece down using the down arrow key. The game will update the state of the board by moving the piece
down by one block every half second, and if the piece can no longer move down, it will be added to
the board and any full lines on the board will be cleared. The game will then create a new falling
piece. If the new piece cannot be placed on the board, the game will end and display an "Game over!"
alert. The game will continuously draw the board and the falling piece on the canvas element using
the draw function, which will be called using requestAnimationFrame.
*/

let rAF;

// Create the canvas
var canvas = document.createElement('canvas');
var ctx = canvas.getContext('2d');

canvas.width = 240;
canvas.height = 400;
document.body.appendChild(canvas);

// Set some initial variables
var blockSize = 20;
var width = canvas.width / blockSize;
var height = canvas.height / blockSize;
var board = [];

for (var i = 0; i < height; i++) {
  board[i] = [];
  for (var j = 0; j < width; j++) {
    board[i][j] = 0;
  }
}

// Create a new falling piece
var fallingPiece;
var fallingPieceX;
var fallingPieceY;

function newPiece() {
  var type = Math.floor(Math.random() * 7);
  var piece;
  if (type === 0) {
    // I-shaped piece
    piece = [[1, 1, 1, 1],
    ];
  } else if (type === 1) {
    // J-shaped piece
    piece = [[1, 0, 0],
    [1, 1, 1],
    ];
  } else if (type === 2) {
    // L-shaped piece
    piece = [[0, 0, 1],
    [1, 1, 1],
    ];
  } else if (type === 3) {
    // O-shaped piece
    piece = [[1, 1],
    [1, 1],
    ];
  } else if (type === 4) {
    // S-shaped piece
    piece = [[0, 1, 1],
    [1, 1, 0],
    ];
  } else if (type === 5) {
    // T-shaped piece
    piece = [[0, 1, 0],
    [1, 1, 1],
    ];
  } else if (type === 6) {
    // Z-shaped piece
    piece = [[1, 1, 0],
    [0, 1, 1],
    ];
  }
  fallingPiece = piece;
  fallingPieceX = Math.floor(width / 2) - Math.floor(piece[0].length / 2);
  fallingPieceY = 0;
}

newPiece();

// Controls
document.addEventListener('keydown', function(e) {
  if (e.keyCode === 37) {
    // Move left
    if (canMove(fallingPiece, fallingPieceX - 1, fallingPieceY)) {
      fallingPieceX--;
    }
  } else if (e.keyCode === 38) {
    // Rotate
    var newPiece = rotate(fallingPiece);
    if (canMove(newPiece, fallingPieceX, fallingPieceY)) {
      fallingPiece = newPiece;
    }
  } else if (e.keyCode === 39) {
    // Move right
    if (canMove(fallingPiece, fallingPieceX + 1, fallingPieceY)) {
      fallingPieceX++;
    }
  } else if (e.keyCode === 40) {
    // Move down
    if (canMove(fallingPiece, fallingPieceX, fallingPieceY + 1)) {
      fallingPieceY++;
    }
  }
});

// Update the game state
function update() {
  if (canMove(fallingPiece, fallingPieceX, fallingPieceY + 1)) {
    fallingPieceY++;
  } else {
    addToBoard(fallingPiece, fallingPieceX, fallingPieceY);
    clearLines();
    newPiece();
    if (!canMove(fallingPiece, fallingPieceX, fallingPieceY)) {
      // Game over
      cancelAnimationFrame(rAF);
      clearInterval(intervalId);
      alert('Game over!');
      window.location.reload();
    }
  }
}

const intervalId = setInterval(update, 500);

// Draw the game state
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBoard();
  drawPiece(fallingPiece, fallingPieceX, fallingPieceY);
  rAF = requestAnimationFrame(draw);
}

draw();

// Helper functions
function canMove(piece, x, y) {
  for (var i = 0; i < piece.length; i++) {
    for (var j = 0; j < piece[i].length; j++) {
      if (piece[i][j]) {
        if (y + i >= height || x + j < 0 || x + j >= width || board[y + i][x + j]) {
          return false;
        }
      }
    }
  }
  return true;
}

function addToBoard(piece, x, y) {
  for (var i = 0; i < piece.length; i++) {
    for (var j = 0; j < piece[i].length; j++) {
      if (piece[i][j]) {
        board[y + i][x + j] = 1;
      }
    }
  }
}

function clearLines() {
  var lines = 0;
  for (var i = height - 1; i >= 0; i--) {
    var lineFull = true;
    for (var j = 0; j < width; j++) {
      if (!board[i][j]) {
        lineFull = false;
        break;
      }
    }
    if (lineFull) {
      lines++;
      for (var j = 0; j < width; j++) {
        board[i][j] = 0;
      }
      for (var k = i; k > 0; k--) {
        for (var j = 0; j < width; j++) {
          board[k][j] = board[k - 1][j];
        }
      }
      i++;
    }
  }
}

function drawBoard() {
  for (var i = 0; i < height; i++) {
    for (var j = 0; j < width; j++) {
      if (board[i][j]) {
        ctx.fillStyle = '#000000';
        ctx.fillRect(j * blockSize, i * blockSize, blockSize, blockSize);
      }
    }
  }
}

function drawPiece(piece, x, y) {
  for (var i = 0; i < piece.length; i++) {
    for (var j = 0; j < piece[i].length; j++) {
      if (piece[i][j]) {
        ctx.fillStyle = '#0000FF';
        ctx.fillRect((x + j) * blockSize, (y + i) * blockSize, blockSize, blockSize);
      }
    }
  }
}

function rotate(piece) {
  var newPiece = [];
  for (var i = 0; i < piece[0].length; i++) {
    newPiece[i] = [];
    for (var j = piece.length - 1; j >= 0; j--) {
      newPiece[i][piece[0].length - j - 1] = piece[j][i];
    }
  }
  return newPiece;
}

export {};
